use super::*;
use lalrpop_util::ParseError;

grammar;

extern {
    type Error = AstError;
}

match {
    r"//[^\r\n]*" => {},
} else { _ }

pub Ident: Ident<'input> = <l:@L> <name:r"[_a-zA-Z]"> <r:@R> => Ident { name, raw_span: Span(l, r) };

pub Integer: Integer = {
    <l:@L> <raw:r"0\d+"> <r:@R> =>? Err(ParseError::User { error: AstError::CStyleOctal { span: Span(l, r) } }),
    <l:@L> <raw:r"((0b|0o|0x)[0-9_]*[0-9]|[1-9][0-9_]*[0-9]|[0-9])([ui](8|16|32|64|128|size))?"> <r:@R> => {
        let (base, raw) = match raw.get(..2) {
            None => (10, raw),
            Some("0b") => (2, &raw[2..]),
            Some("0o") => (8, &raw[2..]),
            Some("0x") => (16, &raw[2..]),
            _ => unreachable!(),
        };
        let raw = &raw[raw.find(|c: char| c != '_').unwrap_or(0)..];
        let (ty, raw) = match raw {
            x if x.ends_with("u8") => (IntType::U8, &x[..x.len() - 2]),
            x if x.ends_with("u16") => (IntType::U16, &x[..x.len() - 3]),
            x if x.ends_with("u32") => (IntType::U32, &x[..x.len() - 3]),
            x if x.ends_with("u64") => (IntType::U64, &x[..x.len() - 3]),
            x if x.ends_with("u128") => (IntType::U128, &x[..x.len() - 4]),
            x if x.ends_with("usize") => (IntType::Usize, &x[..x.len() - 5]),
            x if x.ends_with("i8") => (IntType::I8, &x[..x.len() - 2]),
            x if x.ends_with("i16") => (IntType::I16, &x[..x.len() - 3]),
            x if x.ends_with("i32") => (IntType::I32, &x[..x.len() - 3]),
            x if x.ends_with("i64") => (IntType::I64, &x[..x.len() - 3]),
            x if x.ends_with("i128") => (IntType::I128, &x[..x.len() - 4]),
            x if x.ends_with("isize") => (IntType::Isize, &x[..x.len() - 5]),
            x => (IntType::Unknown, x),
        };
        Integer { value: RugInt::from_str_radix(raw, base).unwrap(), ty, raw_span: Span(l, r) }
    },
};